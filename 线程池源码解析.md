### 线程池源码解析

#### 什么是线程池？

Java中线程池是运用场景最多的并发架构，几乎所有需要**异步或并发执行任务**的程序都可以使用线程池。在开发过程中合理的使用线程池可以带来三个好处：

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度，当任务达到时，任务可以不需要等线程创建就可以执行。
- 提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、和监控。但是要合理利用线程池，必须要对其原理了如指掌。

#### 线程池作用

线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程的时间，从而提高效率。如果一个线程的时间非常长，就没有必要使用线程池了（不是不能长时间操作，而是不宜），况且我们还不能控制线程池中的线程开始、挂起、和终止。

基本用法：

![image-20200505221801447](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200505221801447.png)

```java
//最基本的线程池接口
Executor executor;
//常用的线程池接口
ExecutorService executorService;
//ExecutorService是个接口他需要被创建出来
ThreadPoolExecutor threadPoolExecutor;
```

模板

```java
public static void main(String[] args) {
    ExecutorService es = new ThreadPoolExecutor();
    //执行任务
    es.execute();
    //关闭线程
    es.shutdown();
}
```

面试重点：

1. 线程池工作原理
2. ThreadPoolExecutor各个参数含义

```java
public ThreadPoolExecutor(int corePoolSize, //核心线程数
                          int maximumPoolSize,//最大线程数
                          long keepAliveTime,// 存活时间
                          TimeUnit unit,//时间单位
                          BlockingQueue<Runnable> workQueue, //任务队列
                          RejectedExecutionHandler handler //饱和策略
                         ) {
   this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
}
```

#### 线程池的三种队列

1. SynchrousQueue：

synchrousQueue没有容量，是无缓冲等待队列，是一个不储存元素的阻塞队列，会直接将任务交给消费者，必须等待队列中的添加元素被消费后才能添加新的元素。使用synchrousQueue阻塞队列一般要求maximumPoolSize为无界，避免线程拒绝执行。

2. LinkedBlockQueue

基于链表的先进先出，无界队列。超出直接corePoolSize个任务，则加入到该队列中，直到资源耗尽,所以maximumPoolSize不起作用

3. ArrayBlockQueue

基于数组的先进先出，创建时必须指定大小，超出直接corePoolSize个任务，则加入到该队列中，只能加该queue设置的大小，其余的任务则创建线程，直到(corePoolSize＋新建线程)> maximumPoolSize

#### 饱和策略

- AbortPolicy：Java 线程池默认的阻塞策略，即不执行此新任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute 需要 try catch，否则程序会直接退出。
- CallerRunsPolicy 不抛弃任务，调用线程池的线程帮忙执行任务
- DiscardPolicy：直接抛弃，新任务不执行，空方法
- DiscardOldestPolicy：从队列里面抛弃head的一个任务，并再次execute 此task。抛弃创建最早的任务
- 用户自定义拒绝策略（最常用）：实现RejectedExecutionHandler，并自己定义策略模式

#### Executors线程池工具类

Executors是线程池工具类，他提供了4种线程池的创建办法：

newCachedThreadPool:创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

newFixedThreadPool:创建一个固定长度的线程池，可控制最大并发数，超出的线程会在队列中等待。

newSingleThreadPool:创建一个单线程的线程池，它只会用唯一的工作线去处理任务，保证所有线程按照指定顺序（FIFO，LIFO，优先级）执行

newScheduledThreadPool:创建一个定长的线程池，支持定时及周期性执行任务。

**注意：**

一般我们不建议自己使用Default线程池，因为线程名字是系统提供的，如果出了问题不好定位哪个业务线。

#### 源码解读ThreadPoolExecutor

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
  	//高三位表示线程池运行状态，除去高三位的第29位为线程池中拥有的线程数量
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    //在ctl中，低COUNT_BITS用来保存线程数量 为什么不直接设置29？防止Integer在一些JDK版本中不是4个字节(特殊)
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //表示可以容纳的线程数量 0001 1111 1111 1111 1111 1111 1111 1111
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    //-1的二进制表示为1111 1111 1111 1111 1111 1111 1111 1111
    //右移29位为 1110 0000 0000 0000 0000 0000 0000 0000 0000 这是一个负数
    private static final int RUNNING    = -1 << COUNT_BITS;
    //0000 0000 0000 0000 0000 0000 0000 0000 0000
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    //0010 0000 0000 0000 0000 0000 0000 0000 0000
    private static final int STOP       =  1 << COUNT_BITS;
    //0100 0000 0000 0000 0000 0000 0000 0000 0000
    private static final int TIDYING    =  2 << COUNT_BITS;
    //0110 0000 0000 0000 0000 0000 0000 0000 0000
    private static final int TERMINATED =  3 << COUNT_BITS;

    // Packing and unpacking ctl
    //~0001 1111 1111 1111 1111 1111 1111 1111 = 1110 0000 0000 0000 0000 0000 0000 0000 0000
    //假如c = ctl = 1110 0000 0000 0000 0000 0000 0000 0000 0111
    //结果 1110 0000 0000 0000 0000 0000 0000 0000 0000 也就是获取当前线程的运行状态
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    //获取当前线程数量
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    //用于重置线程ctl值
    //rs: 线程池状态 wc:表示线程池worker(线程)数量
    private static int ctlOf(int rs, int wc) { return rs | wc; }
    //比较当前线程池ctl所处的状态，是否小于某个状态s
    private static boolean runStateLessThan(int c, int s) {
        return c < s;
    }
	//比较当前线程池ctl所处的状态，是否大于等于某个状态s
    private static boolean runStateAtLeast(int c, int s) {
        return c >= s;
    }
	//判断当前线程池状态是否是Runing
    private static boolean isRunning(int c) {
        return c < SHUTDOWN;
    }
    //使用cas的方式使expect+1
    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    //使用cas的方式使expect-1
    private boolean compareAndDecrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect - 1);
    }
	//将ctl值减一
    private void decrementWorkerCount() {
        //失败会重试，知道ctl-1成功为止
        do {} while (! compareAndDecrementWorkerCount(ctl.get()));
    }

 	//任务队列，当线程池中的线程达到核心线程数时，再提交的任务会直接提交到BlockQueue中
    private final BlockingQueue<Runnable> workQueue;

   	//线程池全局锁 增加worker 减少worker时，需要持有mainLock，修改线程池运行状态时，也需要
    private final ReentrantLock mainLock = new ReentrantLock();
	//线程池中真正存放worker->thread的地方
    private final HashSet<Worker> workers = new HashSet<Worker>();
	//条件队列 awaitTermination()方法时，外部线程会等待当前线程池状态直到Termination为止
    //线程池状态变为Termination时，会去通过termination.signalAll()唤醒这些线程
    private final Condition termination = mainLock.newCondition();

  	//记录线程生命周期内，线程的最大值
    private int largestPoolSize;

   	//记录线程池所完成的线程总数，当worker退出时，会将worker所完成的任务累积到completedTaskConunt中
    private long completedTaskCount;
	//创建线程池时，可以使用的线程工厂
    private volatile ThreadFactory threadFactory;

   	//拒绝策略 默认采用AbortPolicy(抛出异常)
    private volatile RejectedExecutionHandler handler;

    //空闲线程存活时间
    private volatile long keepAliveTime;
	//控制核心线程数量内的线程是否可以被回收
    private volatile boolean allowCoreThreadTimeOut;

    //核心线程数量
    private volatile int corePoolSize;

    //线程池最大线程限制
    private volatile int maximumPoolSize;

    /**
     * The default rejected execution handler
     */
    //缺省的拒绝策略
    private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();

  
    private static final RuntimePermission shutdownPerm =
        new RuntimePermission("modifyThread");

    /* The context to be used when executing the finalizer, or null. */
    private final AccessControlContext acc;

    //AbstractQueuedSynchronizer AQS
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        //worker采用了AQS中的独占模式
        //独占模式有两个重要属性 state 和 ExclusiveOwnerThread
        //state = 0时表示未被占用，>0时表示被占用, <0时表示初始状态 这种情况下不能被强锁
        //ExclusiveOwnerThread表示独占锁的线程
        private static final long serialVersionUID = 6138294804551838833L;

        //worker内部封装的工作线程
        final Thread thread;
      //假设fristTask不为null，当worker内部的线程启动后，会有限启动fristTask,执行完后会去queue中获取下个任务
        Runnable firstTask;
        //记录当前worker所完成任务数量
        volatile long completedTasks;

        //firstTask可以为null，启动后去queue中获取
        Worker(Runnable firstTask) {
            //设置AQS独占状态为初始化中，此时不能被抢占锁
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            //使用线程工厂创建一个线程，指定为Runable,也就是说当Thread启动后，会以worker.run()为入口
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        //当work二启动时，会执行run方法
        public void run() {
            //ThreadPoolExecutor.runWorker()是个核心方法，worker启动后逻辑从这里切入。
            runWorker(this);
        }
		//判断当前worker的独占锁是否被占用
        protected boolean isHeldExclusively() {
            return getState() != 0;
        }
		//尝试去占用worker的独占锁
        protected boolean tryAcquire(int unused) {
            //CAS返回值为true表示抢占成功
            if (compareAndSetState(0, 1)) {
                //设置当前线程
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
	   //释放锁，外部不会直接调用这个方法，这个方法是AQS内调用的
       //外部调用unlcok()时，unlock->AQS.release()->tryRelease
        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        //加锁，加锁失败会阻塞当前线程
        public void lock()        { acquire(1); }
        //尝试去加锁 如果当前线程是未被持有的状态会返回true，否则返回false，不会阻塞当前线程
        public boolean tryLock()  { return tryAcquire(1); }
        //一般情况下调用unlock要保证当前线程是持有锁的
        //特殊情况下，worker的state == -1，调用unlock表示初始化state 设置state == 1；
        //启动之前会调用unlock() 强制刷新setExclusiveOwnerThread == null，state==0
        public void unlock()      { release(1); }
        //当前worker是否被占用
        public boolean isLocked() { return isHeldExclusively(); }

        void interruptIfStarted() {
            Thread t;
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }

    /*
     * Methods for setting control state
     */

    /**
     * Transitions runState to given target, or leaves it alone if
     * already at least the given target.
     *
     * @param targetState the desired state, either SHUTDOWN or STOP
     *        (but not TIDYING or TERMINATED -- use tryTerminate for that)
     */
    private void advanceRunState(int targetState) {
        for (;;) {
            int c = ctl.get();
            if (runStateAtLeast(c, targetState) ||
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }


  final void tryTerminate() {
        //自旋
        for (;;) {
            //获取最新ctl值
            int c = ctl.get();
            //条件一：isRunning(c)  成立，直接返回就行，线程池很正常！
            //条件二：runStateAtLeast(c, TIDYING) 说明 已经有其它线程 在执行 TIDYING -> TERMINATED状态了,当前线程直接回去。
            //条件三：(runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty())
            //SHUTDOWN特殊情况，如果是这种情况，直接回去。得等队列中的任务处理完毕后，再转化状态。
            if (isRunning(c) ||
                    runStateAtLeast(c, TIDYING) ||
                    (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
                return;

            //什么情况会执行到这里？
            //1.线程池状态 >= STOP
            //2.线程池状态为 SHUTDOWN 且 队列已经空了

            //条件成立：当前线程池中的线程数量 > 0
            if (workerCountOf(c) != 0) { // Eligible to terminate
                //中断一个空闲线程。
                //空闲线程，在哪空闲呢？ queue.take() | queue.poll()
                //1.唤醒后的线程 会在getTask()方法返回null
                //2.执行退出逻辑的时候会再次调用tryTerminate() 唤醒下一个空闲线程
                //3.因为线程池状态是 （线程池状态 >= STOP || 线程池状态为 SHUTDOWN 且 队列已经空了） 最终调用addWorker时，会失败。
                //最终空闲线程都会在这里退出，非空闲线程 当执行完当前task时，也会调用tryTerminate方法，有可能会走到这里。
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            //执行到这里的线程是谁？
            //workerCountOf(c) == 0 时，会来到这里。
            //最后一个退出的线程。 咱们知道，在 （线程池状态 >= STOP || 线程池状态为 SHUTDOWN 且 队列已经空了）
            //线程唤醒后，都会执行退出逻辑，退出过程中 会 先将 workerCount计数 -1 => ctl -1。
            //调用tryTerminate 方法之前，已经减过了，所以0时，表示这是最后一个退出的线程了。

            final ReentrantLock mainLock = this.mainLock;
            //获取线程池全局锁
            mainLock.lock();
            try {
                //设置线程池状态为TIDYING状态。
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        //调用钩子方法
                        terminated();
                    } finally {
                        //设置线程池状态为TERMINATED状态。
                        ctl.set(ctlOf(TERMINATED, 0));
                        //唤醒调用 awaitTermination() 方法的线程。
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                //释放线程池全局锁。
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }

  
    private void checkShutdownAccess() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPermission(shutdownPerm);
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                for (Worker w : workers)
                    security.checkAccess(w.thread);
            } finally {
                mainLock.unlock();
            }
        }
    }

    /**
     * Interrupts all threads, even if active. Ignores SecurityExceptions
     * (in which case some threads may remain uninterrupted).
     */
  private void interruptWorkers() {
        final ReentrantLock mainLock = this.mainLock;
        //获取线程池全局锁
        mainLock.lock();
        try {
            //遍历所有worker
            for (Worker w : workers)
                //interruptIfStarted() 如果worker内的thread 是启动状态，则给它一个中断信号。。
                w.interruptIfStarted();
        } finally {
            //释放线程池全局锁
            mainLock.unlock();
        }
    }	
    //onlyOne == true 说明只中断一个线程 ，false 则中断所有线程
    //共同前提，worker是空闲状态。
    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        //持有全局锁
        mainLock.lock();
        try {
            //迭代所有worker
            for (Worker w : workers) {
                //获取当前worker的线程 保存到t
                Thread t = w.thread;
                //条件一：条件成立：!t.isInterrupted()  == true  说明当前迭代的这个线程尚未中断。
                //条件二：w.tryLock() 条件成立：说明当前worker处于空闲状态，可以去给它一个中断信号。 目前worker内的线程 在 queue.take() | queue.poll()阻塞中。因为worker执行task时，是加锁的!
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        //给当前线程中断信号..处于queue阻塞的线程，会被唤醒，唤醒后，进入下一次自旋时，可能会return null。执行退出相关的逻辑。
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        //释放worker的独占锁。
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }

        } finally {
            //释放全局锁。
            mainLock.unlock();
        }
    }

    /**
     * Common form of interruptIdleWorkers, to avoid having to
     * remember what the boolean argument means.
     */
    private void interruptIdleWorkers() {
        interruptIdleWorkers(false);
    }

    private static final boolean ONLY_ONE = true;

    /*
     * Misc utilities, most of which are also exported to
     * ScheduledThreadPoolExecutor
     */

    /**
     * Invokes the rejected execution handler for the given command.
     * Package-protected for use by ScheduledThreadPoolExecutor.
     */
    final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }

    /**
     * Performs any further cleanup following run state transition on
     * invocation of shutdown.  A no-op here, but used by
     * ScheduledThreadPoolExecutor to cancel delayed tasks.
     */
    void onShutdown() {
    }

    /**
     * State check needed by ScheduledThreadPoolExecutor to
     * enable running tasks during shutdown.
     *
     * @param shutdownOK true if should return true if SHUTDOWN
     */
    final boolean isRunningOrShutdown(boolean shutdownOK) {
        int rs = runStateOf(ctl.get());
        return rs == RUNNING || (rs == SHUTDOWN && shutdownOK);
    }

    /**
     * Drains the task queue into a new list, normally using
     * drainTo. But if the queue is a DelayQueue or any other kind of
     * queue for which poll or drainTo may fail to remove some
     * elements, it deletes them one by one.
     */
    private List<Runnable> drainQueue() {
        BlockingQueue<Runnable> q = workQueue;
        ArrayList<Runnable> taskList = new ArrayList<Runnable>();
        q.drainTo(taskList);
        if (!q.isEmpty()) {
            for (Runnable r : q.toArray(new Runnable[0])) {
                if (q.remove(r))
                    taskList.add(r);
            }
        }
        return taskList;
    }

    //firstTask可以为null，为null默认从消息队列执行任务，不为null首先执行firstTask
    //core为线程数限制  true采用核心线程数限制 false采用maxiMumPoolSize限制
    
    //返回值总结
    // true 创建worker成功，且线程启动成功
    //false 线程创建失败 4种情况
    //1 线程池状态为STOP TIDYING TERMINATION
    //2 线程状态为SHUTDOWM 但是任务队列没有任务了 或者状态为SHUTDOWN任务队列不为null但是firstTask不为null
    //3 线程数量大于核心线程数量 或者 大于最大线程数量
    //4 ThreadFactory创建出来的线程为null
    private boolean addWorker(Runnable firstTask, boolean core) {
        //自旋 判断当前线程池是否可以创建新的线程
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
             //1 线程池状态为STOP TIDYING TERMINATION
    //2 线程状态为SHUTDOWM 但是任务队列没有任务了 或者状态为SHUTDOWN任务队列不为null但是firstTask不为null
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;
			//上面这些代码，就是判断 当前线程池状态 是否允许添加线程。	
            
            //获取令牌
            for (;;) {
                int wc = workerCountOf(c);
			   //3 线程数量大于核心线程数量 或者 大于最大线程数量
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    //执行到这 说明无法添加线程了 已经达到最大指标了
                    return false;
                //cas获取令牌 条件成立 说明当前线程加一成功
                //条件失败：说明其他线程有可能更改ctl这个值了
                //1 其他线程执行executor并且获取了令牌
                //2 线程池状态改变 因为线程池高三位记录线程池状态 状态改变同样会导致cas失败
                if (compareAndIncrementWorkerCount(c))
                    //结束两次自旋
                    break retry;
                //重新获取ctl 再次去获取令牌
                c = ctl.get();  // Re-read ctl
               //判断当前线程池状态是否改变 改变了需要判断是否满足创建新的线程条件
                if (runStateOf(c) != rs)
                    //线程池状态改变，重新判断下是否满足创建新的线程条件
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        //表示当前创建的worker是否已经启动
        boolean workerStarted = false;
        //表示worker是否添加成功
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建worker 执行完成后线程已经启动了
            w = new Worker(firstTask);
            final Thread t = w.thread;
            //防止程序员头脑过热 修改了ThreadFactory使它不能创建出新的线程
            if (t != null) {
                //将全局锁的引用保存到minLock中
                final ReentrantLock mainLock = this.mainLock;
                //加锁
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());
				  //条件一：rs < SHUTDOWN 成立：最正常状态，当前线程池为RUNNING状态.
                    //条件二：前置条件：当前线程池状态不是RUNNING状态。
                    //(rs == SHUTDOWN && firstTask == null)  当前状态为SHUTDOWN状态且firstTask为空。其实判断的就是SHUTDOWN状态下的特殊情况，
                    //只不过这里不再判断队列是否为空了
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        //防止程序员将ThreadFactory创建的线程start了
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        //判断当前线程数有没有超过当前最大线程数 超过更细最大线程数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //线程以添加到线程池中了
                        workerAdded = true;
                    }
                } finally {
                    //释放锁
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //启动线程
                    t.start();
                    //修改线程状态
                    workerStarted = true;
                }
            }
        } finally {
            //线程启动失败
            if (! workerStarted)
                //1 释放令牌
                //2 删除线程池中的worker
                addWorkerFailed(w);
        }
        //返回线程运行状态
        return workerStarted;
    }

   //线程启动失败的操作
    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        //持有线程池全局锁，因为操作的是线程池相关的东西。
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            //将线程池计数恢复-1，前面+1过，这里因为失败，所以要-1，相当于归还令牌。
            decrementWorkerCount();
           //
            tryTerminate();
        } finally {
            /释放线程池全局锁
            mainLock.unlock();
        }
    }

    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        //条件成立：代表当前w 这个worker是发生异常退出的，task任务执行过程中向上抛出异常了..
        //异常退出时，ctl计数，并没有-1
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            //ctl-1
            decrementWorkerCount();
	    //获取线程池的全局锁引用
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //将当前worker完成的task数量，汇总到线程池的completedTaskCount	
            completedTaskCount += w.completedTasks;
            //将worker从池子中移除..
            workers.remove(w);
        } finally {
            //释放全局锁
            mainLock.unlock();
        }

        tryTerminate();

       //获取最新ctl值
        int c = ctl.get();
        //条件成立：当前线程池状态为 RUNNING 或者 SHUTDOWN状态
        if (runStateLessThan(c, STOP)) {

            //条件成立：当前线程是正常退出..
            if (!completedAbruptly) {

                //min表示线程池最低持有的线程数量
                //allowCoreThreadTimeOut == true => 说明核心线程数内的线程，也会超时被回收。 min == 0
                //allowCoreThreadTimeOut == false => min == corePoolSize
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;


                //线程池状态：RUNNING SHUTDOWN
                //条件一：假设min == 0 成立
                //条件二：! workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程。
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;

                //条件成立：线程池中还拥有足够的线程。
                //考虑一个问题： workerCountOf(c) >= min  =>  (0 >= 0) ?
                //有可能！
                //什么情况下？ 当线程池中的核心线程数是可以被回收的情况下，会出现这种情况，这种情况下，当前线程池中的线程数 会变为0
                //下次再提交任务时，会再创建线程。
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }

            //1.当前线程在执行task时 发生异常，这里一定要创建一个新worker顶上去。
            //2.!workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程。 当前状态为 RUNNING || SHUTDOWN
            //3.当前线程数量 < corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个。
            addWorker(null, false);
        }
    }

    //获取任务队列的任务
     //什么情况下会返回null？
    //1.rs >= STOP 成立说明：当前的状态最低也是STOP状态，一定要返回null了
    //2.前置条件 状态是 SHUTDOWN ，workQueue.isEmpty()
    //3.线程池中的线程数量 超过 最大限制时，会有一部分线程返回Null
    //4.线程池中的线程数超过corePoolSize时，会有一部分线程 超时后，返回null。
    private Runnable getTask() {
        //当前线程是否超时 false未超时 true超时
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
			
            //什么时候条件成立
            //线程状态为shutdown且任务队列为null时
            //线程状态为STOP TIDYING TERMINATION时
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                //ctl-1
                decrementWorkerCount();
                return null;
            }

            //执行到这里，有几种情况？
            //1.线程池是RUNNING状态
            //2.线程池是SHUTDOWN状态 但是队列还未空，此时可以创建线程。

            //获取线程池中的线程数量
            int wc = workerCountOf(c);
 	
            //timed == true 表示当前这个线程 获取 task 时 是支持超时机制的，使用queue.poll(xxx,xxx); 当获取task超时的情况下，下一次自旋就可能返回null了。
            //timed == false 表示当前这个线程 获取 task 时 是不支持超时机制的，当前线程会使用 queue.take();

            //情况1：allowCoreThreadTimeOut == true 表示核心线程数量内的线程 也可以被回收。
            //所有线程 都是使用queue.poll(xxx,xxx) 超时机制这种方式获取task.
            //情况2：allowCoreThreadTimeOut == false 表示当前线程池会维护核心数量内的线程。
            //wc > corePoolSize
            //条件成立：当前线程池中的线程数量是大于核心线程数的，此时让所有路过这里的线程，都是用poll 支持超时的方式去获取任务，
            //这样，就会可能有一部分线程获取不到任务，获取不到任务 返回Null，然后..runWorker会执行线程退出逻辑。
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            //线程回收
            //回收条件一：当前线程大于最大线程数
            //条件二：经过一次自旋 线程超时了
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                //使用CAS机制 将 ctl值 -1 ,减1成功的线程，返回null
                //CAS成功的，返回Null
                //CAS失败？ 为什么会CAS失败？
                //1.其它线程先你一步退出了
                //2.线程池状态发生变化了。
                if (compareAndDecrementWorkerCount(c))
                    return null;
                //再次自旋时，timed有可能就是false了，因为当前线程cas失败，很有可能是因为其它线程成功退出导致的，再次咨询时
                //检查发现，当前线程 就可能属于 不需要回收范围内了。
                continue;
            }

            try {
                //获取任务的逻辑
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                //条件成立：返回任务
                if (r != null)
                    return r;
                //说明当前任务超时了
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }

   //执行任务方法
    final void runWorker(Worker w) {
       	// wt = w.thread
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        //这边为什么调用unlock？
        // 初始化state = 0 和 exclusiveOwnerThread = null
        w.unlock(); // allow interrupts
        
       	//异常退出为true 正常退出false
        boolean completedAbruptly = true;
        try {
            //条件一成立：firstTask不为null
            //条件二成立：从任务队列中获取任务，getTask()是一个会阻塞线程的方法
            //getTask返回为null时，执行结束
            while (task != null || (task = getTask()) != null) {
               	//获取独占锁
                //目的是shutdown会判断当前线程状态，根据独占锁是否空闲判断当前worker是否在工作
                w.lock();
              //条件一：runStateAtLeast(ctl.get(), STOP)  说明线程池目前处于STOP/TIDYING/TERMINATION 此时线程一定要给它一个中断信号
                //条件一成立：runStateAtLeast(ctl.get(), STOP)&& !wt.isInterrupted()
                //上面如果成立：说明当前线程池状态是>=STOP 且 当前线程是未设置中断状态的，此时需要进入到if里面，给当前线程一个中断。

                //假设：runStateAtLeast(ctl.get(), STOP) == false
                // (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)) 在干吗呢？
                // Thread.interrupted() 获取当前中断状态，且设置中断位为false。连续调用两次，这个interrupted()方法 第二次一定是返回false.
                // runStateAtLeast(ctl.get(), STOP) 大概率这里还是false.
                // 其实它在强制刷新当前线程的中断标记位 false，因为有可能上一次执行task时，业务代码里面将当前线程的中断标记位 设置为了 true，且没有处理
                // 这里一定要强制刷新一下。不会再影响到后面的task了。
                //假设：Thread.interrupted() == true  且 runStateAtLeast(ctl.get(), STOP)) == true
                //这种情况有发生几率么？
                //有可能，因为外部线程在 第一次 (runStateAtLeast(ctl.get(), STOP) == false 后，有机会调用shutdown 、shutdownNow方法，将线程池状态修改
                //这个时候，也会将当前线程的中断标记位 再次设置回 中断状态。
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                
                try {
                    //钩子函数，留给子类实现
                    beforeExecute(wt, task);
                    //表示异常情况，如果thrown不为空，表示 task运行过程中 向上层抛出异常了。
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        //钩子函数，留给子类实现
                        afterExecute(task, thrown);
                    }
                } finally {
                    //将局部变量task置为Null
                    task = null;
                    //完成任务++
                    w.completedTasks++;
                    //释放独占锁
                    //1.正常情况下，会再次回到getTask()那里获取任务  while(getTask...)
                    //2.task.run()时内部抛出异常了..跳出循环
                    w.unlock();
                }
            }
            //正常执行跳转到这
            completedAbruptly = false;
        } finally {
            //task.run()内部抛出异常时，直接从 w.unlock() 那里 跳到这一行。
            //正常退出 completedAbruptly == false
            //异常退出 completedAbruptly == true
            processWorkerExit(w, completedAbruptly);
        }
    }

  //构造方法
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

  
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

  
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }

    
    public ThreadPoolExecutor(int corePoolSize,//核心线程数量
                              int maximumPoolSize,//最大线程数量
                              long keepAliveTime,//空闲线程存活时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列
                              ThreadFactory threadFactory,//线程池工厂
                              RejectedExecutionHandler handler //拒绝策略) {
        //判断线程是否越界
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        //任务队列，线程工厂，拒绝策略都不能为null
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

	//command 可以是runable类 也可以是FutureTest
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
 		
        //获取ctl当前的值 高三位是线程状态 低29位为线程数量
        int c = ctl.get();
        //workerCountOf(c)获取当前线程数量
        //当前线程池中线程数量小于核心线程数量，提交此次任务，直接创建一个worker，线程池对应多一个线程
        if (workerCountOf(c) < corePoolSize) {
            //addWorker 即为创建线程的过程，会创建worker对象，并且将command作为firstTask
            //core == true 表示采用核心线程数量限制  false表示采用 maximumPoolSize
            if (addWorker(command, true))
                //创建成功后，直接返回。addWorker方法里面会启动新创建的worker，将firstTask执行。
                return;
            //执行到这说明addWorker一定是失败了
            //有几种可能那
            //1 存在并发现象，execute方法可能有多个线程使用，当workerCountOf(c) < corePoolSize成立后，
            //其它线程可能也成立了，并且向线程池中创建了worker。这个时候线程池中的核心线程数已经达到，所以...
            //2.当前线程池状态发生改变了。 RUNNING SHUTDOWN STOP TIDYING　TERMINATION
            //当线程池状态是非RUNNING状态时，addWorker(firstTask!=null, true|false) 一定会失败。
            //SHUTDOWN 状态下，也有可能创建成功。前提 firstTask == null 而且当前 queue不为空。特殊情况。
            c = ctl.get();
        }
        
        //执行到这有哪几种情况：
        //1 当前线程数已达到核心线程数
        //2 addWorker失败
        
        
 		//当前线程处于Runing则尝试将task放入workQueue中
        if (isRunning(c) && workQueue.offer(command)) {
            //执行到这里 说明任务添加到队列成功了
            //重新获取ctl保存到recheck中
            int recheck = ctl.get();
            //条件一：线程当前状态改变了 shutdown shutdownnow 需要把线程队列中的任务删掉
            //条件二：remove(command) 有可能成功，也有可能失败
            //成功：提交之后，线程池中的线程还未消费（处理）
            //失败：提交之后，在shutdown() shutdownNow()之前，就被线程池中的线程 给处理。
            if (! isRunning(recheck) && remove(command))
                //删除成功 执行拒绝策略
                reject(command);
            //执行到这有两种情况
            //1 线程状态为runing
            //2.线程池状态是非running状态 但是remove提交的任务失败. 
            
            //担心 当前线程池是running状态，但是线程池中的存活线程数量是0，这个时候，如果是0的话，会很尴尬，任务没线程去跑了,
            //这里其实是一个担保机制，保证线程池在running状态下，最起码得有一个线程在工作。
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        
        //执行到这有两种情况
       	//1 当前线程处于非Runing状态
        //2 offer失败
        
        //处于非runing状态 此时command ！= null addWorker肯定失败 一定是返回false 执行拒绝策略
        //offer任务失败，说明当前队列满了，如果当前线程没有超过maxiMumPoolSize，会创建新的worker执行command
        //假设当前线程超过maxiMumPoolSize那么这里会失败 就会执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }

   
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        //获取线程池全局锁
        mainLock.lock();
        try {
            checkShutdownAccess();
            //设置线程池状态为SHUTDOWN
            advanceRunState(SHUTDOWN);
            //中断空闲线程
            interruptIdleWorkers();
            //空方法，子类可以扩展
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }

   
 public List<Runnable> shutdownNow() {
        //返回值引用
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        //获取线程池全局锁
        mainLock.lock();
        try {
            checkShutdownAccess();
            //设置线程池状态为STOP
            advanceRunState(STOP);
            //中断线程池中所有线程
            interruptWorkers();
            //导出未处理的task
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }

        tryTerminate();
        //返回当前任务队列中 未处理的任务。
        return tasks;
    }

    public boolean isShutdown() {
        return ! isRunning(ctl.get());
    }


    public boolean isTerminating() {
        int c = ctl.get();
        return ! isRunning(c) && runStateLessThan(c, TERMINATED);
    }

    public boolean isTerminated() {
        return runStateAtLeast(ctl.get(), TERMINATED);
    }

    public boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (;;) {
                if (runStateAtLeast(ctl.get(), TERMINATED))
                    return true;
                if (nanos <= 0)
                    return false;
                nanos = termination.awaitNanos(nanos);
            }
        } finally {
            mainLock.unlock();
        }
    }

    /**
     * Invokes {@code shutdown} when this executor is no longer
     * referenced and it has no threads.
     */
    protected void finalize() {
        SecurityManager sm = System.getSecurityManager();
        if (sm == null || acc == null) {
            shutdown();
        } else {
            PrivilegedAction<Void> pa = () -> { shutdown(); return null; };
            AccessController.doPrivileged(pa, acc);
        }
    }



    public void setThreadFactory(ThreadFactory threadFactory) {
        if (threadFactory == null)
            throw new NullPointerException();
        this.threadFactory = threadFactory;
    }


    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }


    public void setRejectedExecutionHandler(RejectedExecutionHandler handler) {
        if (handler == null)
            throw new NullPointerException();
        this.handler = handler;
    }

 
    public RejectedExecutionHandler getRejectedExecutionHandler() {
        return handler;
    }

  
    public void setCorePoolSize(int corePoolSize) {
        if (corePoolSize < 0)
            throw new IllegalArgumentException();
        int delta = corePoolSize - this.corePoolSize;
        this.corePoolSize = corePoolSize;
        if (workerCountOf(ctl.get()) > corePoolSize)
            interruptIdleWorkers();
        else if (delta > 0) {
            // We don't really know how many new threads are "needed".
            // As a heuristic, prestart enough new workers (up to new
            // core size) to handle the current number of tasks in
            // queue, but stop if queue becomes empty while doing so.
            int k = Math.min(delta, workQueue.size());
            while (k-- > 0 && addWorker(null, true)) {
                if (workQueue.isEmpty())
                    break;
            }
        }
    }


    public int getCorePoolSize() {
        return corePoolSize;
    }

    public boolean prestartCoreThread() {
        return workerCountOf(ctl.get()) < corePoolSize &&
            addWorker(null, true);
    }

    /**
     * Same as prestartCoreThread except arranges that at least one
     * thread is started even if corePoolSize is 0.
     */
    void ensurePrestart() {
        int wc = workerCountOf(ctl.get());
        if (wc < corePoolSize)
            addWorker(null, true);
        else if (wc == 0)
            addWorker(null, false);
    }

 
    public int prestartAllCoreThreads() {
        int n = 0;
        while (addWorker(null, true))
            ++n;
        return n;
    }

  
    public boolean allowsCoreThreadTimeOut() {
        return allowCoreThreadTimeOut;
    }

   
    public void allowCoreThreadTimeOut(boolean value) {
        if (value && keepAliveTime <= 0)
            throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
        if (value != allowCoreThreadTimeOut) {
            allowCoreThreadTimeOut = value;
            if (value)
                interruptIdleWorkers();
        }
    }

    
    public void setMaximumPoolSize(int maximumPoolSize) {
        if (maximumPoolSize <= 0 || maximumPoolSize < corePoolSize)
            throw new IllegalArgumentException();
        this.maximumPoolSize = maximumPoolSize;
        if (workerCountOf(ctl.get()) > maximumPoolSize)
            interruptIdleWorkers();
    }

    /**
     * Returns the maximum allowed number of threads.
     *
     * @return the maximum allowed number of threads
     * @see #setMaximumPoolSize
     */
    public int getMaximumPoolSize() {
        return maximumPoolSize;
    }

  
    public void setKeepAliveTime(long time, TimeUnit unit) {
        if (time < 0)
            throw new IllegalArgumentException();
        if (time == 0 && allowsCoreThreadTimeOut())
            throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
        long keepAliveTime = unit.toNanos(time);
        long delta = keepAliveTime - this.keepAliveTime;
        this.keepAliveTime = keepAliveTime;
        if (delta < 0)
            interruptIdleWorkers();
    }


    public long getKeepAliveTime(TimeUnit unit) {
        return unit.convert(keepAliveTime, TimeUnit.NANOSECONDS);
    }


    public BlockingQueue<Runnable> getQueue() {
        return workQueue;
    }

   
    public boolean remove(Runnable task) {
        boolean removed = workQueue.remove(task);
        tryTerminate(); // In case SHUTDOWN and now empty
        return removed;
    }

    /**
     * Tries to remove from the work queue all {@link Future}
     * tasks that have been cancelled. This method can be useful as a
     * storage reclamation operation, that has no other impact on
     * functionality. Cancelled tasks are never executed, but may
     * accumulate in work queues until worker threads can actively
     * remove them. Invoking this method instead tries to remove them now.
     * However, this method may fail to remove tasks in
     * the presence of interference by other threads.
     */
    public void purge() {
        final BlockingQueue<Runnable> q = workQueue;
        try {
            Iterator<Runnable> it = q.iterator();
            while (it.hasNext()) {
                Runnable r = it.next();
                if (r instanceof Future<?> && ((Future<?>)r).isCancelled())
                    it.remove();
            }
        } catch (ConcurrentModificationException fallThrough) {
            // Take slow path if we encounter interference during traversal.
            // Make copy for traversal and call remove for cancelled entries.
            // The slow path is more likely to be O(N*N).
            for (Object r : q.toArray())
                if (r instanceof Future<?> && ((Future<?>)r).isCancelled())
                    q.remove(r);
        }

        tryTerminate(); // In case SHUTDOWN and now empty
    }

    /* Statistics */

    /**
     * Returns the current number of threads in the pool.
     *
     * @return the number of threads
     */
    public int getPoolSize() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // Remove rare and surprising possibility of
            // isTerminated() && getPoolSize() > 0
            return runStateAtLeast(ctl.get(), TIDYING) ? 0
                : workers.size();
        } finally {
            mainLock.unlock();
        }
    }

    /**
     * Returns the approximate number of threads that are actively
     * executing tasks.
     *
     * @return the number of threads
     */
    public int getActiveCount() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            int n = 0;
            for (Worker w : workers)
                if (w.isLocked())
                    ++n;
            return n;
        } finally {
            mainLock.unlock();
        }
    }

    /**
     * Returns the largest number of threads that have ever
     * simultaneously been in the pool.
     *
     * @return the number of threads
     */
    public int getLargestPoolSize() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            return largestPoolSize;
        } finally {
            mainLock.unlock();
        }
    }

    /**
     * Returns the approximate total number of tasks that have ever been
     * scheduled for execution. Because the states of tasks and
     * threads may change dynamically during computation, the returned
     * value is only an approximation.
     *
     * @return the number of tasks
     */
    public long getTaskCount() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            long n = completedTaskCount;
            for (Worker w : workers) {
                n += w.completedTasks;
                if (w.isLocked())
                    ++n;
            }
            return n + workQueue.size();
        } finally {
            mainLock.unlock();
        }
    }

    public long getCompletedTaskCount() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            long n = completedTaskCount;
            for (Worker w : workers)
                n += w.completedTasks;
            return n;
        } finally {
            mainLock.unlock();
        }
    }


    public String toString() {
        long ncompleted;
        int nworkers, nactive;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            ncompleted = completedTaskCount;
            nactive = 0;
            nworkers = workers.size();
            for (Worker w : workers) {
                ncompleted += w.completedTasks;
                if (w.isLocked())
                    ++nactive;
            }
        } finally {
            mainLock.unlock();
        }
        int c = ctl.get();
        String rs = (runStateLessThan(c, SHUTDOWN) ? "Running" :
                     (runStateAtLeast(c, TERMINATED) ? "Terminated" :
                      "Shutting down"));
        return super.toString() +
            "[" + rs +
            ", pool size = " + nworkers +
            ", active threads = " + nactive +
            ", queued tasks = " + workQueue.size() +
            ", completed tasks = " + ncompleted +
            "]";
    }

    protected void beforeExecute(Thread t, Runnable r) { }

 
    protected void afterExecute(Runnable r, Throwable t) { }

    /**
     * Method invoked when the Executor has terminated.  Default
     * implementation does nothing. Note: To properly nest multiple
     * overridings, subclasses should generally invoke
     * {@code super.terminated} within this method.
     */
    protected void terminated() { }

    /* Predefined RejectedExecutionHandlers */

    /**
     * A handler for rejected tasks that runs the rejected task
     * directly in the calling thread of the {@code execute} method,
     * unless the executor has been shut down, in which case the task
     * is discarded.
     */
    public static class CallerRunsPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code CallerRunsPolicy}.
         */
        public CallerRunsPolicy() { }

        /**
         * Executes task r in the caller's thread, unless the executor
         * has been shut down, in which case the task is discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run();
            }
        }
    }

    /**
     * A handler for rejected tasks that throws a
     * {@code RejectedExecutionException}.
     */
    public static class AbortPolicy implements RejectedExecutionHandler {
        /**
         * Creates an {@code AbortPolicy}.
         */
        public AbortPolicy() { }

        /**
         * Always throws RejectedExecutionException.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         * @throws RejectedExecutionException always
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }
    }

    /**
     * A handler for rejected tasks that silently discards the
     * rejected task.
     */
    public static class DiscardPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code DiscardPolicy}.
         */
        public DiscardPolicy() { }

        /**
         * Does nothing, which has the effect of discarding task r.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        }
    }

    /**
     * A handler for rejected tasks that discards the oldest unhandled
     * request and then retries {@code execute}, unless the executor
     * is shut down, in which case the task is discarded.
     */
    public static class DiscardOldestPolicy implements RejectedExecutionHandler {
        /**
         * Creates a {@code DiscardOldestPolicy} for the given executor.
         */
        public DiscardOldestPolicy() { }

        /**
         * Obtains and ignores the next task that the executor
         * would otherwise execute, if one is immediately available,
         * and then retries execution of task r, unless the executor
         * is shut down, in which case task r is instead discarded.
         *
         * @param r the runnable task requested to be executed
         * @param e the executor attempting to execute this task
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
        }
    }
}
```

#### 面试题

1. 两个线程交替打印1-100，A线程打印基数，B线程打印偶数

```java
public static void main(String[] args) throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Thread t1 = new Thread(() -> {
        for (int i = 1; i <= 100; i += 2) {
            lock.lock();
            try {
                System.out.println(Thread.currentThread().getName() + "====>" + i);
                condition1.await();
                condition2.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }, "奇数");

    // thread 2
    Thread t2 = new Thread(() -> {
        for (int i = 2; i <= 100; i += 2) {
            lock.lock();
            try {
                System.out.println(Thread.currentThread().getName() + "====>" + i);
                condition1.signal();
                condition2.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }
    }, "偶数");

    t1.setPriority(Thread.MAX_PRIORITY);
    t1.start();
    t2.start();
}
```